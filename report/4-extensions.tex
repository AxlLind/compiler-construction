\section{Possible Extensions}
% If you did not finish what you had planned, explain here what's missing. In any case, describe how you could further extend your compiler in the direction you chose. This section should convince us that you understand the challenges of writing a good compiler for high-level programming languages.
There are so many things you could do to continue the work of this project. An obvious one I did not have time to look at is a better, more sophisticated malloc implementation in the GC. My bitmap implementation for keeping track of allocated/free bytes is simple but very inefficient. To benchmark my GC I created a simple linked list program which does 100 add, contains, and remove operations on a linked list. When compiled with \texttt{-O3} this successfully executes in 0.86 seconds, while the JVM backend does so in 0.03 (which includes the relatively slow JVM start-up time). The JVM has also had decades of work put into it's garbage collector, and entire PhD's written about how to make it performant. It is still very much an open problem of how to do concurrent garbage collection effectively. So, my approach to the tracing GC could be extended and improved a lot, for example by using multiple threads and work-stealing queues to mark the heap in parallel.

An additional performance drawback to my approach is to figure out when to actually collect garbage. For this proof of concept I simply added a call to \texttt{gc\_collect()} at the end of every function call. This is needlessly aggressive. An interesting extension would be how to insert garbage collection in a more sophisticated way. One idea I had was to start a timer in a separate thread, to garbage collect at a specific interval. That however leads to questions of how to stop the main thread from allocating and so on. Another idea I had was to use a background thread which sends a signal to the program at an interval, and collecting in the signal handler. Once again, you would have to think carefully about what to do if the main thread for example is in the middle of allocating.

Lastly, one thing I did not have time to implement was increasing the garbage collectors internal memory, to support programs that require arbitrary amounts of memory. Currently, the GC allocated 2 MB on start-up and if it runs out of memory it crashes. This could quite easily be solved by allocating a new memory area whenever the first one does not fit the allocation.